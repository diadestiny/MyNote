const int MAX_N = 50;
//入门题目
int main(int argc, char**argv)

{
	int n, m, k[MAX_N];
	scanf("%d %d", &n, &m);
	for (int i = 0; i < n; i++)
	{
		scanf("%d", &k[i]);
	}
	bool f = false;
	for(int a=0;a<n;a++)
		for(int b=0;b<n;b++)
			for(int c=0;c<n;c++)
				for(int d=0 ;d<n;d++)
					if (k[a] + k[b] + k[c] + k[d] == m)
					{
						f = true;
					}
	if (f)
		puts("Yes");
	else
		puts("No");
	return 0;

}
//蚂蚁题
int L, n;
int x[MAX_N];

void solve()
{
	int minT = 0;
	for (int i = 0; i < n; i++)
	{
		minT = max(minT, min(x[i], L - x[i]));
	}
	int maxT = 0;
	for (int i = 0; i < n; i++)
	{
		maxT = max(maxT, max(x[i], L - x[i]));
	}
	printf("%d %d", minT, maxT);
}
//入门题优化
//输入
int n, m, k[MAX_N];
//二分查找
bool binary_search(int x)
{
	int l = 0, r = n;
	while (r - l >= 1)
	{
		int i = (l + r) / 2;
		if (k[i] == x)
			return true;
		else if (k[i] < x) l = i + 1;	
		else r = i;
		
	}
	return false;
}

void solve()
{
	sort(k, k + n);
	bool f = false;
	for (int a = 0; a < n; a++) {
		for (int b = 0; b < n; b++) {
			for (int c = 0; c < n; c++) {
				if (binary_search(m - k[a] - k[b] - k[c]))
				{
					f = true;
				}
			}
		}
	}
	if (f) puts("Yes");
	else puts("No");
}
//入门题再次优化
//输入
int n, m, k[MAX_N];
int kk[MAX_N*MAX_N];
//二分查找
bool binary_search(int x)
{
	int l = 0, r = n*n;
	while (r - l >= 1)
	{
		int i = (l + r) / 2;
		if (kk[i] == x)
			return true;
		else if (kk[i] < x) l = i + 1;	
		else r = i;
		
	}
	return false;
}

void solve()
{
	for(int c=0;c<n;c++)
	{
		for (int d = 0; d < n; d++)
		{
			kk[c*n + d] = k[c] + k[d];
		}
	}
	sort(kk, kk + n);
	bool f = false;
	for (int a = 0; a < n; a++) {
		for (int b = 0; b < n; b++) {
			
				if (binary_search(m - k[a] - k[b]))
				{
					f = true;
				}
		}
	}
	if (f) puts("Yes");
	else puts("No");
}
//部分和问题
int a[MAX_N];
int n, k;

bool dfs(int i, int sum)
{
	if (i == n )
		return sum == k;

	if (dfs(i + 1, sum)) return true;
	if (dfs(i + 1, sum + a[i])) return true;
	return false;
}
void solve()
{
	if (dfs(0, 0))
		cout << "Yes" << endl;
	else cout << "No" << endl;
}
//水洼问题
int N, M;
char field[MAX_N][MAX_M + 1];
void dfs(int x, int y)
{
	field[x][y] = '.';
	for (int dx = -1; dx <= 1; dx++) {
		for (int dy = -1; dy <= 1; dy++) {
			int nx = x + dx;
			int ny = y + dy;
			if (0 <= nx && nx < N && 0 <= ny && ny < M &&field[nx][ny] == 'w')
				dfs(nx, ny);

		}
	}
	return;
}
void solve()
{
	int res = 0;
	for (int i = 0; i < N; i++) {
		for (int j = 0; j < M; j++)
		{
			if (field[i][j] == 'w')
			{
				dfs(i, j);
				res++;
			}
		}
	}
	cout << res<< endl;
}
//迷宫问题

const int INF = 100000000;
typedef pair<int, int> P;

char maze[MAX_N][MAX_M + 1];
int N, M;
int sx, sy, gx, gy;
int d[MAX_N][MAX_M];
int dx[4] = { 1,0,-1,0 };
int dy[4] = { 0,1,0,-1 };
int bfs()
{
	queue<P> que;
	for (int i = 0; i < N; i++)
		for (int j = 0; j < N; j++)
			d[i][j] = INF;
	que.push(P(sx,sy));
	d[sx][sy] = 0;
	while (que.size())
	{
		P p = que.front();
		que.pop();
		if (p.first == gx && p.second == gy)
			break;
		for (int i = 0; i < 4; i++)
		{
			int nx = p.first + dx[i], ny = p.second + dy[i];
			if (0 <= nx && nx < N && 0 <= ny && ny < M&&maze[nx][ny] != '#'&&d[nx][ny] == INF)
			{
				que.push(P(nx, ny));
				d[nx][ny] = d[p.first][p.second] + 1;
			}
		}
	}
	return d[gx][gy];
}
void solve()
{
	int res = bfs();
	printf("%d\n", res);
}
//硬币题
const int V[6] ={1,5,10,50,100};
int C[6];
int A;
void solve()
{
    int ans =0;
    for(int i=5;i>=0;i++)
    {
        int t =min(A/V[i]),C[i]);
        A-=t*V[i];
        ans+=t;
    }
    printf("%d\n",ans);
}
//区间调度问题
const int MAX_N = 100000;
int N,S[MAX_N],T[MAX_N];
pair<int,int> itv[MAX_N];

void solve()
{
    // 对pair进行的是字典序比较
   // 为了让结束时间早的工作排在前面，把T存入first, 把S存入second
    for(int i=0;i<N;i++)
    {
        itv[i].first=T[i];
        itv[i].second=S[i];
    }
    sort(itv,itv+N);
    //t说是最后所选工作的结束时间
    int ans=0,t=0;
    for(int i=0;i<N;i++)
    {
        if(t<itv[i].second)
        {
            ans++;
            t=itv[i].first;
        }

    }
}
//字典序最小问题
int N;
char S[MAX_N+1];

void solve()
{
 int a=0,b=N-1;
 while(a<=b)
 {
     bool left =false;
     for(int i=0;a+i<=b;i++)
     {
         if(S[a+i]<S[b-i])
         {
             left=true;
             break;
         }
         else if(S[a+i]>S[b-i])
         {
             left = false;
            break;
         }
        
     }
      if(left) putchar(S[a++]);
         else putchar(S[b--]);       
 }
 putchar('\n');
}
//至少标记点问题
int N,R;
int X[MAX_N];

void solve()
{
 sort(X,X+N);
 int i=0,ans=0;
 while(i<N)
 {
     int s = X[i++];
     while(i<N && X[i]<=s+R)
     i++;
     ans++;
 }
printf("%d\n",ans);
}
//木板问题
typedef long long ll;
int N,L[MAX_N];
void solve()
{
  ll ans=0;
  while(N>1)
  {
      // 求出最短的板miil和次短的板mii
      int mii1=0, mii2 = 1;
      if(L[mii1] > L[mii2])    
       swap(mii1,mii2);
       for(int i=2;i<N;i++)
       {
           if(L[i]<L[mii1])
           {
               mii2 = mii1;
               mii1 = i;
           }
           else if(L[i]<L[mii2])
           {
               mii2 = i;
           }
       }
       //将两块板拼合
       int t = L[mii1]+L[mii2];
       ans += t;
       if(mii1== N-1) swap(mii1,mii2);
       L[mii1] = t;
       L[mii2] = L[N-1];
       N--;
 }
//背包问题
int n,W;
int w[MAX_N],v[MAX_N];

int rec(int i,int j)
{
    int res;
    if(i==n)
    {
        res=0;
    }
    else if(j<w[i])
    {
        res=rec(i+1,j);
    }
    else{
        res = max(rec(i+1,j),rec(i+1,j-w[i])+v[i]);
    }
    return res;
}

void solve()
{
    printf("%d",rec(0,W));
}
//蓝桥杯第四题测试次数

#define Max(a,b) (a>b?a:b)

#define Min(a,b) (a<b?a:b)

int dp[1005][50];

int main(int argc, char* argv[])

{

	int n, m;

	scanf("%d%d", &n, &m);

	for (int i = 1; i <= n; i++)

		dp[i][1] = i;

	for (int cnt = 2; cnt <= m; cnt++)

	{

		for (int ind = 1; ind <= n; ind++)

		{

			dp[ind][cnt] = 1 + dp[ind - 1][cnt];

			for (int k = 2; k < ind; k++)

				dp[ind][cnt] = Min(dp[ind][cnt], 1 + Max(dp[k - 1][cnt - 1], dp[ind - k][cnt]));

		}

	}

	printf("%d\n", dp[n][m]);

	return 0;

}
