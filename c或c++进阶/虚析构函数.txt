C++中基类的析构函数为什么要用virtual虚析构函数？

/*

基础知识:
静态类型是指不需要考虑表达式的执行期语义，仅分析程序文本而决定的表达式类型。
静态类型仅依赖于包含表达式的程序文本的形式，而在程序运行时不会改变。通俗的讲，就是上下文无关，在编译时就可以确定其类型。

动态类型是指由一个左值表达式表示的左值所引用的最终派生对象的类型。
例：如果一个静态类型为“类 B ”的指针p 指向一个继承于 B的类 D 的对象，则表达式 *p 的动态类型为“D”。
引用按照相似规则处理。一般地讲，基类的指针和基类引用有可能为动态类型，就是说在运行之前不能够确定其真实类型。
通常我们说，“基类指针指向的对象的实际/真正类型”或“基类引用所引用的对象的实际/真正类型”，就是它们的动态类型。
很显然，这个动态类型是  C++ 语言通过指针和引用实现运行时多态能力的核心概念。

简单地说，虚函数是动态绑定的基础；动态绑定是实现运行时多态的基础。
要触发动态绑定，需满足两个条件：
(1)  只有虚函数才能进行动态绑定，非虚函数不进行动态绑定。
(2)  必须通过基类类型的引用或指针进行函数调用。

*/

原因是基类指针指向了派生类对象，而基类中的析构函数却是非virtual的，
之前讲过，虚函数是动态绑定的基础。现在析构函数不是virtual的，因此不会发生动态绑定，而是静态绑定，指针的静态类型为基类指针，
因此在delete时候只会调用基类的析构函数，而不会调用派生类的析构函数。
这样，在派生类中申请的资源就不会得到释放，就会造成内存泄漏，这是相当危险的：
如果系统中有大量的派生类对象被这样创建和销毁，就会有内存不断的泄漏，久而久之，系统就会因为缺少内存而崩溃。