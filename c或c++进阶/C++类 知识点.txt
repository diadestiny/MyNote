//默认无参构造函数出现隐藏条件：当没有(显示无参 显示有参 显示拷贝构造 ）函数
//默认拷贝构造函数出现隐藏条件：没有显示的拷贝构造函数
//默认析构函数出现隐藏条件：当没有显示的析构函数
/*当一个函数返回（return）一个匿名对象，函数外部没有任何的变量去接受他，这个匿名对象不会被再使用（找不到），编译会直接把这个匿名对象回收掉，
而不是等待整个函数执行完毕后再去回收 */

//在没有初始化的前提下，并不会触发拷贝构造函数，而是将匿名对象转赠给t1，相当于帮这个匿名对象起了个名字。
//显示的提供一个拷贝构造函数 深拷贝(mallco开辟空间 避免指向相同的位置

//构造对象成员的顺序与构造函数初始化列表顺序无关，与private定义列表顺序有关 
//析构的顺序与构造相反

//new在堆上初始化一个对象的时候，会触发对象的构造函数,malloc不能
//free并不能触发一个对象的析构函数 delete可以

//静态成员变量的初始化，一定在类的外面。
class vvv
{public: static int heigh;} 
 int vvv::heigh =100;

class vvv
{pub;ic: static void change(int h){heigh =h};
private: static int heigh ;} 
vvv::change(300);

//方法不属于对象中
//this就是指向调用该成员函数方法的对象地址
//this 指针不是const Test *  是一个常指针 Test *const
//成员函数尾部出现const 修饰的是this指针
//static成员函数，只能返回static成员变量  因为this指向的是调用方法的对象，static 不属于对象，属于类

//如果想返回一个对象的本身，return *this
//如果想对一个对象连续调用成员方法，每次都会改变对象本身，成员方法需要返回引用。

//同类对象无私处 异类对象有友元
//友元只具有单向性，不具有传递性

//左移操作符只能写在全局 不能写在成员方法中 否则调用的顺序会变反，(对象)<<cout；

// operator=   指针  防止自身赋值 先将自身的格外开辟空间回收掉 执行深拷贝

//继承规则:1.只要是父类中的private成员 不管是什么继承  儿子都访问不了
//规则2.如果是公有继承，儿子中的访问控制权限保持不变
//规则3.如果是保护继承，儿子中父亲中除了private成员，其他成员都是protected成员
//规则4.如果是私有保护，儿子中的父亲除了private成员，其他也都是privated成员

//三看原则:看调用的对象成员变量是在类的内部还是类的外部，看儿子的继承方式，当前变量在儿子中的变量在父亲中的访问控制权利


//子类对象可以当作父类对象使用
//子类对象可以直接赋值给父类对象
//子类对象可以直接初始化父类对象
//父类指针可以直接指向子类对象
//父类引用可以直接引用子类对象

//在调用子类的构造函数，一定会调用父类的构造函数

//父类 子类成员重名情况事 如果是共有的 域名访问 如果是私有的  需要父类提供共有方法来获得

//多继承 爷爷 爸爸 儿子  在爸爸public: 前面加个virtual 多继承与虚继承

//多态发生的三个必要条件 要有继承 要有虚函数重写 父类指针或引用指向子类对象

//重载:一定是同一个作用域下 重定义:是发生在两个不同的类，一个是父类，一个是子类 
//1.普通函数重定义 //如果父类的普通成员函数被子类重写，说是重定义
//2.虚函数重写 如果父类的虚函数被子类重写，就是虚函数重写，这个函数会发生多态